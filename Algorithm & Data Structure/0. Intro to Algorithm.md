# 演算法初步

演算法是一連串明確、會終止的計算步驟。雖然說這個學科聽起來像是在討論「要怎麼設計出一個解出問題的演算法？」，但實際上，這門學科是在討論「==問題有多難解？==」在這邊，「問題」的定義是：==一個「輸入」與「輸出」的對應關係==。舉例來說，「玩魔術方塊問題」，的輸入跟輸出是：

```
輸入：一個轉亂的魔術方塊
輸出：6 面顏色都是一樣的魔術方塊
```

又比如說「河內塔問題」：

```
輸入：按照「下大上小」順序，放在最左方柱子的一排中空圓盤
輸出：按照「下大上小」順序，放在最右方柱子的一排中空圓盤
```

或是「找最大值問題」：

```
輸入：一個大小為 N 的有序集合 A
輸出：一個整數 max，A[max] 比 A 中所有元素都大
```

這些都是問題的例子。

# 計算模型

在思考「這個問題有多難解？」知歉，要考慮的是「遊戲的規則是什麼？」。以「魔術方塊問題」為例，如果限制在「魔術方塊只能用轉的」，跟「可以把魔術方塊拆掉重組」，可能出現的解法就不相同; 而以「河內塔問題」為例「一次只能搬動一個圓盤」跟「一次可以搬動任意數目的圓盤」，出現的解法也不同。

# 難度的上界

==TL;DR：構造一個正確的演算法來說明難度上界。==

想要知道難度的上限有多難，方法就是構造一個「正確」的解題的方法，然後說對於任意一個輸入的「個例」，都可以保證在多少「步驟」之內解完。比如說：

```c
int max = 0;
for (int i = 1; i < N; i++)
    if (A[i] > A[cur_max]);
		max = i;
```

在說明這個解法有多難之前，要先說明這個做法是「正確」的。

1. 當 N = 1 時，這個做法顯然成立
2. 當 N = k > 1 時，假定這個做法可以解出所有大小為 `k - 1` 的問題，則：
   1. 迴圈從 `i = 0` 到 `i = k - 2` 時，迴圈的步驟跟解一個大小為 `k - 1` 的問題經歷的步驟完全一樣。所以這時後，`max` 是 `A[0]` ... `A[k - 2]` 中最大那個數的 index。
   2. 當 `i = k - 1` 次迴圈時：1) 如果這時 `A[k - 1]` 比較大，那 `max` 就會被更新成 `i` ，也就是 `k - 1`。因為這時 `A[k - 1]` 比 `A[0]` ... `A[k - 2]` 中最大的還大，也就是他是 `A` 陣列中最大的元素。2) 如果 `A[k - 1]` 比 `A[max]` 小，而 `A[max]`已經是前面 `A[0]` ... `A[k-2]`中最大的，這時程式會讓 `max` 會維持原來的值，而這個 `A[max]` 既然是前面 `k - 1` 個數字中最大的，又比第 `k` 個數字大，所以他就會是 `k` 個數字東最大的。

確定這個解法的正確性之後，接著看看這個問題需要多少功夫。這邊用「比較的次數」作為標準。這個解法需要比較「N - 1」次，所以需要的功夫就是「 N - 1 次比較」。

# 難度的下界

==TL;DR：用各種證明方式，說明任意一個做法至少需要多少功夫來解決任意個例。==

比如說：
$$
「每個數字至少進行一次比較」
$$
這樣的話，至少要比較 $n / 2$ 次，所以一個可能的下界是 $n / 2 $ 次比較。

或者是另外一個估計：
$$
每次比較最多可以淘汰 1 個數字，所以最少要比較\ N - 1\ 次
$$
不然永遠沒辦法知道鹿死誰手。因此，這個新的下界就是 $N - 1$ 次比較。

# 任務：上界 = 下界

以比大小問題為例：

1. 有做法可以用 N - 1 次比較生出結果。
2. 對於任意作法，至少需要比較 N - 1 次才可以知道結果。

因此這個問題的難度就是 $N - 1$ 次比較。

# 問題：難度的標準

一天領一百萬，跟第 $n$ 天領 $2^n$ ，每天領下去，最後 $2^n$ 的領法會領比較多。假設現在有兩個演算法，對於大小 $N$ 的任意輸入，一個輸入法最差需要 $1,000,000N$ 的計算步驟，另外一個最差需要 $2^N$ 個計算步驟。這時候該用什麼標準怎麼比較呢？這時候就需要引入「漸進記號」了。