# Deadlock

基本概念是：a 等 b、b 等 c、c 等 a。因為大家都在~~踢皮球~~互相等對方，所以永遠等不到。Deadlock 有四個講到不能再講的必要條件：
$$
\begin{cases}
\text{Mutual Exclusion} & \text{有東西沒辦法共用} \newline
\text{Hold and Wait} & \text{一邊持有一個資源，一邊等下一個資源} \newline
\text{No Preemtable} & \text{資源不能被搶} \newline
\text{Circulate Wait} & \text{等待順序繞一圈}
\end{cases}
$$
這些條件並不是互相獨立的。比如說要 Circulate Wait 就一定會看到 No Preemtable，不然直接搶就好; 另外一方面，都已經有 Circulate "Wait" 了，所以當然有出現 Hold and Wait。

防 Deadlock 有幾種方法：

1. 不要理他：Deadlock 發生就發生。這是寫程式的人的錯。
2. Deadlock Prevention：不要讓那四條條件其中一條出現，就不可能有 Deadlock (因為那是必要條件)。
3. Deadlock Avoidance：要用資源時，不要讓 Process 自己去拿，而是要作業系統先同意，由作業系統進行安排。

## Deadlock Prevention

把前面 4 個條件幹掉其中一條（不過也不是每一條都可以解決）。比如說：

1. Mutual Exclusion：這聽起來需要，因為多執行緒的時候總是要避免 Race 嘛。所以不會拿這個開刀。

2. Hold and Wait：舉例來說用下面這種解法：假定現在要做的事情是「從隨身碟把東西拷貝到電腦中，接著給連著電腦的印表機列印」。為了方便就叫這個順序 $u, v, w$。這時：

   * 解法一：

     等 $u, v$ 同時有空時，兩個一起抓起來。並且做事情，做完之後兩個都還回去。

     等 $v, w$ 同時有空時，兩個一起抓起來。並且做事情，做完之後兩個都還回去。

     但問題是放掉 $\{u, v\}$ 時，$v$ 也會被放掉，這時其他人會對 $v$ 做什麼是沒辦法保證的。這聽起來滿糟糕的，因為白話文就是「放任 Race Condition 就絕對不會 Deadlock」。

   * 解法二：==一次拿到所有資源詞可以做事==。以這個為例，就是要

      $u, v, w$ 同時都有空時，而且去抓的時候三個都同時抓到，開始做事情。做完放掉。

     但這問題也很明顯，比如說如果全部東西都用很久，其他要用資源的人通通就被 block 在那邊。所以會等很久造成 Starvtion: 另外資源使用率也會降低（因為一次拿了一堆東西，但又只用一個）。

3. No Preemptiion：這個解法就是如果有人要搶，就給他搶吧。搶之前先讓他保存好狀態。但這明顯有個問題：這樣一來會花很多時間在內鬥上面。因此一種改良是：要搶資源前，看資源的持有者是不是正在 Waiting 狀態。有的話再把東西拿過來。

4. Circulating：

   ==Type 1==：解法是像夾自助餐，把所有資源標好號碼排一排，規定一定要照號碼順序「夾菜」，並且不能回頭。因為不能回頭，所以一定沒有 Circle。

   ==Type 2==一個改良是：如果拿到一半發現少拿東西要退回去，就要把少拿的那個東西之後拿的東西先放回原位。

   這問題也滿明顯的，因為舉例來說現在我需要使用的資源依序是 $u, v, w$，但規定的存取順序是 $w, v, u$，這樣一來就要等 $ｗ$、拿 $w$、等 $v$、拿 $v$、等 $u$、拿 $u$ 才可以開始做事情。因此也有 Starvation 跟使用率低的問題



